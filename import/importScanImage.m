function data=importScanImage(fname,index)
% Import a tiff generated by ScanImage
%
% function data=importScanImage(fname,index)
%
% Purpose
% ScanImage saves each trial as a separate multi-image tiff. This
% file imports one of these tiffs, saving it as a .mat file for
% using with subsequent functions. It also creates a data structure
% which can be turned into a twoPhoton object.
%
% Inputs
% * fname - a string indicating which file to load. ** If fname is a 
%   directory, then the function imports all tiff files in that directory. 
% * index - the index in the structure into which this data will be
%   stored. index is optional and ==1 by default.
%
% Examples:
% One. Import all SI tiffs in the current directory
% data=importScanImage 
% data=importScanImage(pwd)
%
% Two. Import just one tiff file
% data=import('rep001.tif')
%
% Three. Import just one tiff file and treat is at the second repeat
% data=import('rep001.tif',2)
%
%
% Rob Campbell - December 2011

if nargin==0
    fname=pwd;
end

%If the user has supplied nothing or a directory
if isdir(fname)
	curDir=pwd;
	cd(fname)
	files=dir('*.tif');

	for ii=1:length(files)
		fname=files(ii).name;
		fprintf('%d/%d. %s',ii,length(files),fname)
		L=length(fname);
		index=str2double(fname([L-6:L-4]));
		data(ii)=worker(fname,index);
		fprintf('\n')
	end
	data=generateDFFobject(data);
	cd(curDir)
	return
end


%If the user has supplied file name and (optionally) an index
if nargin<2
    index=1; 
end

if isstr(fname)
    data=worker(fname,index);
    data=generateDFFobject(data);
end




function data=worker(fname,index)
[imageStack,imageInfo]=load3Dtiff(fname);



%now we pull out all the useful meta-data from imageInfo
for ii=1:length(imageInfo)
    meta(ii)=readScanImageMeta(imageInfo(ii).ImageDescription);
end


%Build the "info" structure. We won't just copy the structure made
%by ScanImage because the data analysis routines which exist
%already need to work with with ScanImage structure. 

data.info.Filename=imageInfo(1).Filename;
data.info.date=imageInfo(1).FileModDate;

data.info.pixelsPerLine=single(imageInfo(1).Width);
data.info.linesPerFrame=single(imageInfo(1).Height);
data.info.binningMode=int8(0); %I don't think ScanImage does cumulative intensity
data.info.frameAveraging=int8(meta(1).acq.averaging);

data.info.framePeriod=single(1/meta(1).acq.frameRate);
data.info.scanlinePeriod=single(meta(1).acq.msPerLine/1000);
data.info.dwellTime=single(meta(1).acq.pixelTime*1E6);  %micro seconds


%bit-depth
if data.info.pixelsPerLine<512
    bitDepth=16;
else
    bitDepth=14;
end
imageStack=imageStack/2^bitDepth; %to normalise image 


data.info.bitDepth=int8(meta(1).acq.inputBitDepth); %I THINK THIS IS RIGHT

data.info.positionCurrent_XAxis=single(meta(1).motor.absXPosition);
data.info.positionCurrent_YAxis=single(meta(1).motor.absYPosition);
data.info.positionCurrent_ZAxis=single(meta(1).motor.absZPosition);

data.info.rotation=single(meta(1).acq.scanRotation);

%The optical zoom 
data.info.opticalZoom=meta(1).acq.zoomFactor;

data.info.micronsPerPixel_XAxis=pullData(meta,'motor','absXPosition');
data.info.micronsPerPixel_YAxis=pullData(meta,'motor','absYPosition');
data.info.micronsPerPixel_ZAxis=pullData(meta,'motor','absZPosition');


%The field is needed for some down-stream functions to work
data.info.type='scanimage';

%e.g. SecondsPerScanLine=0.002116
%tmp=regexp(id,'SecondsPerScanLine=(\d+\.\d+)','tokens');
%tmp=str2double(tmp{1}{1});
%data.info.SecondsPerScanLine=tmp;

%e.g. DelayToFirstImagePixelInSecs=0.009176
%tmp=regexp(id,'DelayToFirstImagePixelInSecs=(\d+\.\d+)','tokens');
%tmp=str2double(tmp{1}{1});
%data.info.DelayToFirstImagePixelInSecs=tmp;

%tmp=imageInfo(1).Height;
%data.info.LineNumber=tmp;

% Calculate the frame rate
% I am unsure why 0.1 is being added here:
%And before we figure out if there is/how to ripe out the "resting time"
%information, we would adding up it manually as value of 0.1s of which we
%generally got.

%tmp=size(imageStack,1)*data.info.SecondsPerScanLine+...
%    data.info.DelayToFirstImagePixelInSecs+0.1;
%data.info.framePeriod=tmp;


%data.relativeFrameTimes=zeros(1,size(imageStack,3)); %fill with nothing

%These are necessary for later functions to work
data.info.rawDataDir=pwd;
data.info.stimIndex=index;

%We will now want to re-arrange the image stack if there are
%multiple channels. 
nChan=meta(1).acq.numberOfChannelsSave;
nFrames=meta(1).acq.numberOfFrames; %Number of frames the user asked for
nFramesActual=size(imageStack,3); %Number of frames recorded
tmp=zeros([size(imageStack,1),size(imageStack,2),nFrames,nChan]);
if nFrames~=nFramesActual*nChan %Because it interleaves channels
    fprintf('Expected %d frames found %d frames\n',nFrames, ...
            nFramesActual)
end



%Re-arrange image stack into a multidimensional matrix where the
%third dimension is time and the fourth is channel
for ii=1:nChan
    tmp(:,:,1:nFramesActual/nChan,ii)=imageStack(:,:,ii:nChan:size(imageStack,3));
end
imageStack=single(tmp); %Takes up half the space of an array of doubles


%The relative frame times are here because some other functions use
%this as an indicator of the number of frames. Such a thing could
%be implemented another way, of course, but that's how we've done
%it from Prairie View data. 
data.relativeFrameTimes=nan(1,nFrames); 




%Save the imported imageStack as a .mat file in the data directory
data.info.rawDataFile=sprintf('rawData%d',index);
eval([data.info.rawDataFile,'=imageStack;']) 

fileStr=[data.info.rawDataDir,'/',data.info.rawDataFile];
save(fileStr,data.info.rawDataFile)



        
        
function out=pullData(meta,varA,varB)
%Pull out all data in particular branch of meta. assumes it will be
%a numerical scalar

out=ones(1,length(meta));

for ii=1:length(meta)
    out(ii)=meta(ii).(varA).(varB);
end

nChan=meta(1).acq.numberOfChannelsSave;
out=single(out(1:nChan:length(out)));

