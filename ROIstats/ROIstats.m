function OUT = ROIstats(data,ROIindex,doPlot,alpha,doFDR,extraTime)
% dF/F for each cell over time
%
% function OUT = ROIstats(data,ROIindex,doPlot,alpha,doFDR,extraTime)
% 
% Purpose
% Calculate dF/F for each ROI over time and determines which cells
% respond significantly. Optionally, plots the results using an
% external function call. The ROI is generally generated by selectROIs.
% 
% INPUTS
% data -  should be the smoothed, motion-corrected, and
% photobleach-corrected structure (e.g. data) produced by functions
% cleanImageStack.m and PhotoBleachCorrection.m
%
% ROIindex - the index of the ROI structure for which stats should
% be calculated. By default it finds the field named 'soma' and
% calculates stats for that. This variable is optional and can be
% an index or a string (it looks up the ROI names in ROI.notes).
%
% doPlot - 0 be default. if ==1 then make pretty plots. 
%
% alpha - the significance level [0.01 by default]
%
% doFDR - apply the FDR based approach to determine significance:
%         see main body of function. [Optional, zero by default].
%
% extraTime [optional, see responsePeriodFrames for default] - 
% defines for how long after the end of the stimulus we will
% average the dF/F. If it's a vector length 2 then it defines the
% start and end frame we will use for the analysis.
%
%
% OUTPUTS
% Calculates a matrix of ROI dF/F for each frame and the indecies
% which were significant. 
%
% Rob Campbell June 2009,
%
% also see: addROIstats, plotROIstats
%
%
%----------------------------------------------------------------------
% NOTE:
% Significance test algorithm is:
% - Determine the SD of the baseline period
% - Choose alpha level (e.g. 0.01). Using the baseline, determine
%   number of SDs which correspond to this alpha for a one-sided
%   test. This is the threshold for significance
% - Smooth function and save this 
% - The response is significant if one or more frames during the
%   "response period" (stim period plus 3 seconds) is greater than
%   this threshold. 
% 
% As noted above, it is possible to apply the False Discovery Rate
% (FDR) to this: http://en.wikipedia.org/wiki/False_discovery_rate
%
% This test _does_ assume that the values in the baseline are
% normally distributed. If this is not the case, then p-value will
% be "wrong." The result is that alpha=0.05 may not be a good boundary
% for a significance cut-off. The user should look at the
% distribution of p-values over all experiments, search for an
% elbow in the graph, and use that p-value as the threshold. This
% was the procedure employed in Honegger, Campbell & Turner, 2011
% (J. Neurosci.). 
%----------------------------------------------------------------------


  
error(nargchk(1,5,nargin))
if nargin<2, ROIindex='soma'; end
if nargin<3, doPlot=0; end
if nargin<4 | isempty(alpha), alpha=0.01; end
if nargin<5 | isempty(doFDR), doFDR=0; end
if nargin<6 , extraTime=[]; end

if alpha<0  | alpha>1, error('alpha out of range'), end

if ischar(ROIindex)
    ROIindex=strmatch(ROIindex,{data.ROI.notes});

    %Fail if we can't find the ROI
    if isempty(ROIindex) 
      fprintf('Can''t find ROI\n')
      return
    end    
end
ROI=data.ROI(ROIindex);

    


%We can work out the dF/F either pixelwise or by ROI. The pixelwise
%method basis the calculation on data.dff. The ROI calculation uses
%data.imageStack and calculates the mean intensity for each ROI
%for each frame. This produces a very similar answer and should, in
%theory, be more noise resistant. It's also about 2 to 4 times
%faster!

%dff=byPixel(data,ROI);
dff=byROI(data,ROI);

if isfield(data.info,'type')
    if strmatch('TSeries ZSeries',data.info.type)
        OUT.dff=dff;
        return
    end
end

    


%----------------------------------------------------------------------
%Start and end of the "response period"
rp=responsePeriodFrames(data(1),extraTime);
if length(extraTime)<2
    sF=rp(1); 
    eF=rp(2);
else
    sF=extraTime(1);
    eF=extraTime(2);
end


if size(dff,2)<eF
    fprintf('Not enough movie frames. Skipping\n')
    OUT.sigResponses=nan;
    OUT.dff=nan;
    OUT.alpha=nan;
    OUT.sigRank=nan;
    OUT.pValue=nan;
    OUT.doFDR=nan;    
    OUT.responseFrames=[sF,eF];
    return
end


%If the baseline drifts a lot and this isn't corrected then we will
%over-estimate the SD and reduce the incidence of significance responses. 
if isempty(data.ignoreFrames)
    startFrame=1;
else
    startFrame=data.ignoreFrames+1; %ignores the first so many frames
end

%We want a long baseline since we are going to estimate the SD. 
%Note that we are using the first frame value calculated by
%responsePeriodFrames and not sF. This is because sF may have an
%inappropriate value if it's been over-ridden. 
baseline=startFrame:(rp(1)-1); 



n=1;
sigResponses=[];
sigRank=nan([1,size(dff,1)]);
pValue=nan([1,size(dff,1)]);


for ii=1:size(dff,1)
  tmp=dff(ii,:);

  SD=std(tmp(baseline));
  mu=mean(tmp(baseline));
  threshSD=abs(norminv(alpha,0,1)); %One-tailed test!
  thresh=mu+(threshSD*SD);
  
  %Now we look for the presence of points which have a likelihood of
  %<alpha of coming from the baseline distribution. This isn't quite a
  %peak-based method but it is similar. There are two ways of doing
  %this. If we use the false discovery rate (FDR) then we work out
  %p-values on the raw data, correct the p-values, then smooth for
  %visualisation. If we don't use the FDR then we smooth FIRST,
  %then work out the p-values. The FDR approach is important if you
  %have a long response window. For shorter windows the two
  %approaches give similar answers but the non-FDR method is more
  %lenient. 
  

  if doFDR
    %Smooth AFTER when doing the FDR
    pVal=1-normcdf(tmp(sF:eF),mu,SD);
    tmp=smooth(tmp,'lowess');
    dff(ii,:)=tmp;
    pID=FDR(pVal,alpha);
  else
    tmp=smooth(tmp,'lowess');
    dff(ii,:)=tmp;
    pVal=1-normcdf(tmp(sF:eF),mu,SD);
    pID=alpha;
  end

  
  
  if isempty(pID)
      L=0;
  else
      L=length(find(pVal<=pID));
  end
  pValue(ii)=min(pVal);
  if L>=1, sigResponses(n)=ii; n=n+1; end %one significant frame
  sigRank(ii)=L; %the significance rank is just the number of significant frames
  
end


%Make output structure
OUT.sigResponses=sigResponses;
OUT.dff=dff;
OUT.alpha=alpha;
OUT.sigRank=sigRank;
OUT.pValue=pValue;
OUT.doFDR=doFDR;

if doPlot
  plotROIstats(data,'sigRank',OUT)
end










%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function DFF=byPixel(data,ROI)

imageStack=squeeze(data.imageStack); %Extract stack data from disk
dff=data.dff;

%Work out the dF/F for each cell
numFrames = size(imageStack,3); 


masks=ROI.roi;
numCells = length(unique(masks(:)))-1;%because of zero

DFF = ones(numCells,numFrames);
dff=reshape(dff,[size(dff,1)*size(dff,2),numFrames]);
masks=masks(:);
for ii = 1:numCells        
    tmp1 = dff(masks==ii,:);
    mu=mean(tmp1,1);
    %REMOVES BASELINE from each cell seperately.
    DFF(ii,:)=mu-mean(mu(data.preFrames)); 
end




function DFF=byROI(data,ROI)
im=squeeze(data.imageStack); %Extract stack data from disk

%Work out the dF/F for each cell
numFrames = size(im,3);
masks=ROI.roi(:);
Umasks=unique(masks);
Umasks(Umasks==0)=[];
numCells = length(Umasks(:));

DFF = ones(numCells,numFrames);

im=permute(im,[1,2,4,3]); %without this the reshape is garbled
im=reshape(im,[size(im,1)*size(im,2)*size(im,3),numFrames]);

for ii = 1:length(Umasks)
    m=Umasks(ii);

    mu = mean(im(find(masks==m),:),1);
    F=mean(mu(data.preFrames));
    dff=(mu-F)/F;

    %REMOVES BASELINE from each cell seperately.
    dff=dff-mean(dff(data.preFrames));

    DFF(ii,:)=dff; 
end

