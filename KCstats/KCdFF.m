function stats = KCdFF(data,doPlot,alpha,doFDR,extraTime)
% dF/F for each cell over time
%
% function stats=KCdFF(data,doPlot,alpha,doFDR,extraTime)
% 
% Purpose
% Calculate dF/F for each KC over time and determines which cells
% respond significantly. Optionally, plots the results using an
% external function call. KC masks generated by selectKCs.
% 
% INPUTS
% data -  should be the smoothed, motion-corrected, and
% photobleach-corrected structure (e.g. data) produced by functions
% cleanImageStack.m and PhotoBleachCorrection.m
% doPlot - 0 be default. if ==1 then make pretty plots. 
% alpha - the significance level [0.01 by default]
% doFDR - apply the FDR based approach to determine significance:
%         see main body of function. [Optional, zero by default].
% extraTime [optional, see responsePeriodFrames for default] - 
% defines for how long after the end of the stimulus we will
% average the dF/F. If it's a vector length 2 then it defines the
% start and end frame we will use for the analysis.
%
%
% OUTPUTS
% Calculates a matrix of KC dF/F for each frame and the indecies
% which were significant. 
%
% Rob Campbell June 2009,
%
% also see: addKC_stats, plotKCdFF


%----------------------------------------------------------------------
% NOTE:
% Significance test algorithm is:
% - Determine the SD of the baseline period
% - Choose alpha level (e.g. 0.01). Determine number of SDs which
%   correspond to this alpha for a one-sided test. This is the
%   threshold for significance
% - Smooth function and save this 
% - The response is significant if one or more frames during the
%   "response period" (stim period plus 3 seconds) is greater than
%   this threshold. 
% 
% As noted above, it is possible to apply the False Discovery Rate
% (FDR) to this: http://en.wikipedia.org/wiki/False_discovery_rate
%----------------------------------------------------------------------


  
error(nargchk(1,5,nargin))
if nargin<2, doPlot=0; end
if nargin<3 | isempty(alpha), alpha=0.01; end
if nargin<4 | isempty(doFDR), doFDR=0; end
if alpha<0  | alpha>1, error('alpha out of range'), end
if nargin<5 , extraTime=[]; end


%We can work out the dF/F either pixelwise or by ROI. The pixelwise
%method basis the calculation on data.dff. The ROI calculation uses
%data.imageStack and calculates the mean intensity for each KC
%for each frame. This produces a very similar answer and should, in
%theory, be more noise resistant. It's also about 2 to 4 times
%faster!


%kcDFF=byPixel(data);
kcDFF=byROI(data);

if strmatch('TSeries ZSeries',data.info.type)
    stats.kcDFF=kcDFF;
    return
end


%----------------------------------------------------------------------
%Start and end of the "response period"
rp=responsePeriodFrames(data(1),extraTime);
if length(extraTime)<2
    sF=rp(1); 
    eF=rp(2);
else
    sF=extraTime(1);
    eF=extraTime(2);
end

if size(kcDFF,2)<eF
    fprintf('Not enough movie frames. Skipping\n')
    stats.sigResponses=nan;
    stats.kcDFF=nan;
    stats.alpha=nan;
    stats.sigRank=nan;
    stats.pValue=nan;
    stats.doFDR=nan;    
    return
end


%If the baseline drifts a lot and this isn't corrected then we will
%over-estimate the SD and reduce the incidence of significance responses. 
if isempty(data.ignoreFrames)
    startFrame=1;
else
    startFrame=data.ignoreFrames+1; %ignores the first so many frames
end

%We want a long baseline since we are going to estimate the SD. 
%Note that we are using the first frame value calculated by
%responsePeriodFrames and not sF. This is because sF may have an
%inappropriate value if it's been over-ridden. 
baseline=startFrame:rp(1); 



n=1;
sigResponses=[];
sigRank=nan([1,size(kcDFF,1)]);
pValue=nan([1,size(kcDFF,1)]);


for i=1:size(kcDFF,1)
  tmp=kcDFF(i,:);

  SD=std(tmp(baseline));
  mu=mean(tmp(baseline));
  threshSD=abs(norminv(alpha,0,1)); %One-tailed test!
  thresh=mu+(threshSD*SD);
  
  %Now we look for the presence of points which have a likelihood of
  %<alpha of coming from the baseline distribution. This isn't quite a
  %peak-based method but it is similar. There are two ways of doing
  %this. If we use the false discovery rate (FDR) then we work out
  %p-values on the raw data, correct the p-values, then smooth for
  %visualisation. If we don't use the FDR then we smooth FIRST,
  %then work out the p-values. The FDR approach is important if you
  %have a long response window. For shorter windows the two
  %approaches give similar answers but the non-FDR method is more
  %lenient. 
  

  if doFDR
    %Smooth AFTER when doing the FDR
    pVal=1-normcdf(tmp(sF:eF),mu,SD);
    tmp=smooth(tmp,'lowess');
    kcDFF(i,:)=tmp;
    pID=FDR(pVal,alpha);
  else
    tmp=smooth(tmp,'lowess');
    kcDFF(i,:)=tmp;
    pVal=1-normcdf(tmp(sF:eF),mu,SD);
    pID=alpha;
  end

  
  
  if isempty(pID)
      L=0;
  else
      L=length(find(pVal<=pID));
  end
  pValue(i)=min(pVal);
  if L>=1, sigResponses(n)=i; n=n+1; end %one significant frame
  sigRank(i)=L; %the significance rank is just the number of significant frames
  
end


%Make output structure
stats.sigResponses=sigResponses;
stats.kcDFF=kcDFF;
stats.alpha=alpha;
stats.sigRank=sigRank;
stats.pValue=pValue;
stats.doFDR=doFDR;

if doPlot
  plotKCdFF(data,'sigRank',stats)
end










%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function kcDFF=byPixel(data)

imageStack=squeeze(data.imageStack); %Extract stack data from disk
dff=data.dff;

%Work out the dF/F for each cell
numFrames = size(imageStack,3); 
masks=data.KCmasks;
numCells = length(unique(masks(:)))-1;%because of zero


kcDFF = ones(numCells,numFrames);
dff=reshape(dff,[size(dff,1)*size(dff,2),numFrames]);
masks=masks(:);
for ii = 1:numCells        
    tmp1 = dff(masks==ii,:);
    mu=mean(tmp1,1);

    %REMOVES BASELINE from each cell seperately.
    kcDFF(ii,:)=mu-mean(mu(data.preFrames)); 
end



function kcDFF=byROI(data)
im=squeeze(data.imageStack); %Extract stack data from disk

%Work out the dF/F for each cell
numFrames = size(im,3); 
masks=data.KCmasks(:);
Umasks=unique(masks);
Umasks(Umasks==0)=[];
numCells = length(Umasks(:));

kcDFF = ones(numCells,numFrames);

im=permute(im,[1,2,4,3]); %without this the reshape is garbled
im=reshape(im,[size(im,1)*size(im,2)*size(im,3),numFrames]);

for ii = 1:length(Umasks)
    m=Umasks(ii);  

    mu = mean(im(find(masks==m),:),1);
    F=mean(mu(data.preFrames));
    dff=(mu-F)/F;

    %REMOVES BASELINE from each cell seperately.
    dff=dff-mean(dff(data.preFrames));

    kcDFF(ii,:)=dff; 
end

